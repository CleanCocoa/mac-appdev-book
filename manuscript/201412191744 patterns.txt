## List of Patterns You Might not Know Yet


### Model--View--View Model (MVVM)

There's your core _domain model_. Around it, you build an application with its interface. The user interface is called _view_. So far, so similar to MVC.

Now an MVC controller will usually have access to the model data and the view, or the view will be bound to the model and update itself automatically on model changes. The latter is sometimes called _smart view pattern_. As we'll see, I don't like either of that. A basic Domain-Driven Design principle I adhere to is this: domain objects should not bleed into other layers of the application. At least not if they're mutable, that is, if they're Aggregates. You can argue that read-only entities would do no harm, but I yet have to come across something like this.

To get some data, any data into the view, MVVM introduces the _view model_ or [_presentation model_][presmodel]. Application of this pattern vary, but they all have in common that the view model is a container for the data of the domain model. The domain model is thus shielded from the user interface. I came to think that the view model is "a model for the view", but people repeatedly say it's a "model of the view" instead. Depending on your interpretation, how you apply the pattern will vary of course.

* Dumb Data-Transfer Objects are "a model for the view".
* More complex presenters, taking care of assembling data from the model for the view, are "a model of the view."

In the Ruby on Rails world, the presenter has become a service object which holds on to the domain model and exposes its data in a way meaningful to the view. Say you've got a `Person` entity with `firstName` and `lastName`. A `PersonPresenter` will take care of assembling a `fullName`, to display a list of `Person`s, for example. You can go all nuts here: create a `PersonListPresenter` for displaying full names in a list, and a `PersonFormPresenter` for exposing both first and last name to edit them in a form, say. This way, the view can be as dumb as possible. 

To me, setting up a presenter for a domain model objects sounds like preparing "a model for the view." After all, you pass the presenter in! But I learned to think about it from a different perspective. Utilizing dependency inversion, the presenter is indeed injected into the view, but its interface is specified by means of the view component arrangement. In other words, you set up a presenter which the view specifies, so the presenter actually belongs in the user interface layer.

[presmodel]: http://martinfowler.com/eaaDev/PresentationModel.html
