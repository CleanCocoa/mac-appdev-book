## Introducing Events in Place of Notifications {#domainevents}

Using `NSNotificationCenter` is easy and a well-known practice. I don't like how working with a notifications `userInfo` dictionary changed with Swift and its enforcement of strong typing.

### Swift is sticking your head right at the problems

In Objective-C, I'd send and access the "Box was created" event info like this:

{linenos=off}
    // Sending
    NSDictionary *userInfo = @[@"boxId": @(boxId.identifier)]
    [notificationCenter postNotificationName: kBoxProvisioned,
                                      object: self,
                                    userInfo: userInfo]
    
    // Receiving
    int64_t identifier = notification.userInfo["boxId"].longLongValue
    [BoxId boxIdWithIdentifier: identifier]

To get this deep in Swift, I have to do this instead:

{linenos=off}
    // Sending
    let userInfo = ["boxId" : NSNumber(longLong: boxId.identifier)]
    notificationCenter.postNotificationName(kBoxProvisioned, 
        object: self, userInfo: userInfo)
    
    // Receiving
    let boxInfo = notification.userInfo!["boxId"] as NSNumber
    let boxId = BoxId(boxInfo.longLongValue)

I settled for sending IDs only because putting ID and title makes things complicated for the "Item was created" event. There, I'd have to use nested dictionaries. A JSON representation would look like this:

{title="JSON representation of the event data", linenos=off, lang=json}
    {
        box: {
            id: ...
        }
        item: {
            id: ...
            title: "the title"
        }
    }

Accessing nested dictionaries in Swift is even worse, though, so I settled with supplying two IDs only. On the downside, every client now has to fetch data from the repository to do anything with the event. That's nuts.

The relative pain Swift imposes highlights possible problems: there could be no `userInfo` at all, there could be no value for a given key, and there could be a different kind of value than you expect. Even more so with nested dictionaries of the type `[NSObject : AnyObject]`.

It's almost always a bad idea to simply assume that the event publisher provided valid data in dictionaries. What if the dictionary keys change but you didn't notice in the client? Defining constants remedies the problem a bit. 

You have to perform sanity checks to catch invalid events anyway, in Objective-C just as much as in Swift.

Using real event objects will work wonders. Serializing them into dictionaries and de-serializing `userInfo` into events will encapsulate the sanity checks and provide usable interfaces tailored to each event's use.

{pagebreak}


### Event Value Types

An event should be a value type, and thus a struct. It assembles a `userInfo` dictionary. For `NSNotificationCenter` convenience, it also assembles a `NSNotification` object:

{title="Domain Event serializing itself into userInfo dictionary"}
    // Provide a typealias for brevity and readability
    typealias UserInfo = [NSObject : AnyObject]
    
    struct BoxProvisionedEvent: DomainEvent {
        let boxId: BoxId
        let title: String
    
        init(boxId: BoxId, title: String) {
            self.boxId = boxId
            self.title = title
        }
    
        func userInfo() -> UserInfo {
            return [
                "id": NSNumber(longLong: boxId.identifier),
                "title": title
            ]
        }
    
        func notification() -> NSNotification {
            return NSNotification(name: kBoxProvisioned, object: nil, 
                userInfo: userInfo())
        }
    }

A domain event should also de-serialize from existing `userInfo` data. Unwrapping the dictionary is trivial.

Now `BoxProvisionedEvent` wraps the `NSNotification` in something more meaningful. It also provides convenient accessors to its data, the ID and title of the newly created box. That's good for slimming-down the subscriber: no need to query the repository for additional data.

With the changes in place, the `DisplayBoxesAndItems` Application Service now does no more than this: 

    class DisplayBoxesAndItems {
        func subscribe() {
            let mainQueue = NSOperationQueue.mainQueue()
        
            boxProvisioningObserver = publisher.subscribe(
                    BoxProvisionedEvent.self, queue: mainQueue) {
                [unowned self] event in

                let boxData = BoxData(boxId: event.boxId, title: event.title)
                self.consumeBox(boxData) // Notice how misleading this reads?
                                         // That has to change soon.
            }
            
            // ...
        }
        
        func consumeBox(boxData: BoxData) {
            if let consumer = self.consumer {
                consumer.consume(boxData)
            }
        }
        
        // ...
    }

The `subscribe` method is interesting. Thanks to [Swift generics][generics], I can specify an event type using `TheClassName.self` and pipe it through to the specified block to easily access the values.

The conversion of `NSNotification` to the appropriate domain event takes place in the `DomainEventPublisher`:

    public func subscribe<T: DomainEvent>(eventKind: T.Type, 
            queue: NSOperationQueue, 
            usingBlock block: (T!) -> Void) -> NSObjectProtocol {
        let eventType: DomainEventType = T.eventType
        return notificationCenter.addObserverForName(eventType.name, 
                object: nil, queue: queue) { notification in
        
            let userInfo = notification.userInfo!
            let event: T = T(userInfo: userInfo)
            block(event)
        }
    }

It takes some getting used to Swift to read this well. Let's stick to the client code from above and see what subscribing to `BoxProvisionedEvent`s does:

* The type of the `eventKind` argument should the type (not instance!) of a descendant of `DomainEvent`. That's what `BoxProvisionedEvent.self` is. You don't pass in an actual event, but it's class (or "type"). Interestingly, this value is of no use but to set `T`, the generics type placeholder.
* The `block` (line 3) yields an event object of type `T` (an instance of `BoxProvisionedEvent`)
* The `eventType` (line 4) is an enum value. In this example case, this will be `BoxProvisionedEvent.eventType`, which returns the enum value `DomainEventType.BoxProvisioned`. `DomainEventType`s have a property called `name` to return a string which becomes the notification name:

    {linenos=off}
        enum DomainEventType: String {
            case BoxProvisioned = "Box Provisioned"
            case BoxItemProvisioned = "Box Item Provisioned"
    
            var name: String {
                return self.rawValue
            }
        }
        
* The actual observer is a wrapper around the `block` specified by the client. The wrapper creates an event of type `T`. All `DomainEvent`s must provide the deserializing initializer `init(userInfo: [NSObject : AnyObject])`, and so does `T`:
    
    {linenos=off}
        protocol DomainEvent {
            /// The `DomainEventType` to identify this kind of DomainEvent
            class var eventType: DomainEventType { get }
    
            init(userInfo: UserInfo)
            func userInfo() -> UserInfo
            func notification() -> NSNotification
        }

When a `BoxProvisioned` event is published, it is transformed into a `NSNotification`. The notification is posted as usual. The wrapper around the client's subscribing block receives the notification, de-serializes a `BoxProvisioned` event again, and provides this to the client.

It took some trial and error to get there, but it's pretty clever if I may say that much myself.[^d0a8c7b56296961a662bd1681b134dfe550adfff]

<!--ct: commit
#d0a8c7b56296961a662bd1681b134dfe550adfff use real DomainEvents instead of notifications
#9a8f41d29b1bd48eb1d6f7475699da0d0d925c2b add TestDomainEventPublisher and NullNotificationCenter for isolating tests
#a2b0f4c578abbe4407d5cc06b7fc423472cb8151 test ProvisioningService sending domain events
#74cf8041d561e6ecbe696dbb8f9c5d6046005405 refactor code for domain events
-->

[^d0a8c7b56296961a662bd1681b134dfe550adfff]: See [commits d0a8c7b](https://github.com/DivineDominion/mac-appdev-code/commit/d0a8c7b56296961a662bd1681b134dfe550adfff),  [9a8f41d](https://github.com/DivineDominion/mac-appdev-code/commit/9a8f41d29b1bd48eb1d6f7475699da0d0d925c2b),  [a2b0f4c](https://github.com/DivineDominion/mac-appdev-code/commit/a2b0f4c578abbe4407d5cc06b7fc423472cb8151), and [74cf804](https://github.com/DivineDominion/mac-appdev-code/commit/74cf8041d561e6ecbe696dbb8f9c5d6046005405)

[generics]: http://swiftyeti.com/generics/

